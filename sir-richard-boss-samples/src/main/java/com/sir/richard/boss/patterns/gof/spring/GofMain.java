package com.sir.richard.boss.patterns.gof.spring;
//https://habr.com/ru/company/otus/blog/451516/

public class GofMain {

    private static final String TEXT = """
Вот некоторые известные паттерны, используемые в Spring Framework:

Proxy (Заместитель)
Singleton (Одиночка)
Factory (Фабрика)
Template (Шаблон)
Model View Controller (Модель-Представление-Контроллер)
Front Controller (Контроллер запросов)
View Helper (Вспомогательный компонент представления)
Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления)
Service Locator (Локатор служб)
Observer-Observable (Наблюдатель)
Context Object (Контекстный объект)

Proxy (Заместитель)

Паттерн Proxy широко используется в AOP и remoting.

Хороший пример использования Proxy — это org.springframework.aop.framework.ProxyFactoryBean.
Эта фабрика создаёт AOP-прокси на основе Spring-бина.
Прокси предоставляет заместителя для другого объекта, чтобы контролировать доступ к нему.

Singleton (Одиночка)
Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы.
В Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер.
Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект.
Рекомендуется использовать область видимости singleton для бинов без состояния.
Область видимости бина можно определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина).

Пример конфигурации в xml-файле:
<!-- Определение бина с областью видимости singleton -->
<bean id = "..." class = "..." scope = "singleton/prototype">
   <!-- здесь конфигурация бина -->
</bean>

Factory (Фабрика)
Этот паттерн позволяет инициализировать объект через публичный статический метод, называемый фабричным методом.
Spring использует паттерн Factory для создания объекта бина с использованием следующих двух подходов.
BeanFactory
Простой контейнер, который обеспечивает базовую поддержку DI (Dependency Injection, инъекция зависимостей). Для работы с этим контейнером используется интерфейс org.springframework.beans.factory.BeanFactory.
ApplicationContext
Другой контейнер, присутствующий в Spring, который добавляет специфичные enterprise-функции. Эти функции включают в себя возможность чтения параметров из property-файлов и публикацию событий приложения для слушателей событий.
Для работы с этим контейнером используется интерфейс org.springframework.context.ApplicationContext.
Ниже приведены наиболее часто используемые реализации ApplicationContext.
FileSystemXmlApplicationContext — в конструкторе необходимо указать полный путь к XML-файлу с конфигурацией бинов.
ClassPathXmlApplicationContext — необходимо поместить XML-файл с конфигурацией бинов в CLASSPATH.
XmlWebApplicationContext — загружает XML-файл с метаданными бинов в веб-приложении.

Template (Шаблон)
Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).
Например, JdbcTemplate, JmsTemplate, JpaTemplate (Примечание переводчика: JpaTemplate объявлен устаревшим с Spring 3.1).

Model View Controller (Модель-Представление-Контроллер)
Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.
View Helper (Вспомогательный компонент представления)
В Spring есть несколько пользовательских JSP-тегов и макросов Velocity, помогающие отделить код от представления.
View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.
Фреймворки, такие как Spring и Struts, предоставляют собственные библиотеки тегов для инкапсуляции логики обработки в хелперах вместо размещения логики в представлении, таком как JSP-файлы.

Dependency injection и inversion of control (IOC) (Внедрение зависимостей и инверсия управления)
IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения.
В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).

Service Locator (Локатор служб)
ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин.
Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.

Observer-Observable (Наблюдатель)
Используется в механизме событий ApplicationContext.
Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

Context Object (Контекстный объект)
Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу.
ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.
    
""";
    public static void main(String[] args) {
        System.out.println(TEXT);
    }
}
